create database products ;

select * from products 
where category = "Plus" ;



# I have directly imported the dataset from scv to table using mysql workbench 










# code of setting api for databse


from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import SQLAlchemyError

app = Flask(__name__)

# Database configuration
app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+mysqlconnector://root:Ybi@$!15drt6749@localhost/products'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # Disable modification tracking
db = SQLAlchemy(app)

# Product model
class Product(db.Model):
    __tablename__ = 'products'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.String(255))
    price = db.Column(db.Float, nullable=False)

    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'price': self.price
        }


@app.route('/api/products', methods=['GET'])
def get_products():
    try:
        # Get pagination parameters from query string (default to page 1 and 10 items per page)
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)

        # Query the database with pagination
        products = Product.query.paginate(page, per_page, False).items

        # Return products as JSON
        return jsonify([product.to_dict() for product in products]), 200

    except SQLAlchemyError as e:
        return jsonify({"error": "Database Error", "message": str(e)}), 500



@app.route('/api/products/<int:id>', methods=['GET'])
def get_product(id):
    try:
        # Find product by ID
        product = Product.query.get(id)

        # If product is not found, return 404 error
        if product is None:
            return jsonify({"error": "Not Found", "message": f"Product with ID {id} not found."}), 404

        # Return the product as JSON
        return jsonify(product.to_dict()), 200

    except SQLAlchemyError as e:
        return jsonify({"error": "Database Error", "message": str(e)}), 500




@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal Server Error", "message": "An unexpected error occurred."}), 500


@app.errorhandler(404)
def not_found_error(error):
    return jsonify({"error": "Not Found", "message": "The requested resource could not be found."}), 404




if __name__ == '__main__':
    app.run(debug=True)







# Initialize the database tables (use this once to create tables)#
#with app.app_context():
#    db.create_all()
